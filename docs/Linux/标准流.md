# 标准流

参考：

https://www.runoob.com/linux/linux-shell-io-redirections.html

https://program-think.blogspot.com/2019/11/POSIX-TUI-from-TTY-to-Shell-Programming.html?q=bash&scope=all

[TOC]

> pipeline(管道符)，==将前一个命令的stdout做为后一个命令的stdin==，采用FIFO

```
cat filename | command1 && >> filname.bak
```

会先执行command1 然后将filename中的内容写入到filename.bak中

## 概述

在POSIX系统中，每个进程都内置了三个“standard stream”(标准流)，stdin(标准输入流)，stdout(标准输出流)，stderr(标准错误输出流)

<img src="..\..\imgs\_Linux\480px-Stdstreams-notitle.svg.png"/>

当你在程序中打开某个文件，会得到一个“文件描述符”（洋文叫“[file descriptor](https://en.wikipedia.org/wiki/File_descriptor)”，简称 fd）。fd 本身是个整数，程序员可以通过 fd 对该文件进行读写。
而进程的三个【标准流】，就相当于是三个特殊的 fd。当进程启动时，操作系统就已经把这三个 fd 准备好了。
由于这三个玩意儿是预先备好滴，所以它们的数值分别是：0、1、2（参见上图中 # 后面的数字）。

## 标准流的重定向

> 如果流A被重定向到B流，但是B流被重定向到文件C，那么，A和B都会被保存到文件C中

- 输入流重定向

  把某个文件重定向为stdin；此时进程通过stdin读取的是该文件内容。使用`<`来表示

  ```
  cat < 文件名
  ```

  > 注意echo 使用的并不是输入流，而是命令行参数，cat命令就是输入流，类似的还有wc

<img src="..\..\imgs\_Linux\Snipaste_2020-10-11_13-49-37.png"/>

- 输出流重定向

  把stdout重定向到==某个文件==，`>`覆盖文件内容，`>>`追加文件内容

  ==`>`等价于`1 >`，将标准输出重定向==
  
  ```
  echo hello > redirect
echo hello >> redirect
  ```
  
  > 2>&1 表示将stderr(2)==合并==到stdout(1)，错误信息将会显示在屏幕
  >
  > ```
  > echo hello > redirect 2>&1
  > echo hello >> redirect 2>&1
  > ```
  >
  > 可以将&理解为整合通道，如果没有&，将被bash理解为文件
  >

`cat`命令还可以起到类似“文件复制”效果

```
cat < src > dest
```

> 某些同学可能会问了：既然能这么玩，为啥还需要用 `cp` 命令进行文件复制捏？
> 原因在于：`cat` 的玩法，只保证内容一样，其它的不管；而 `cp` 除了复制文件内容，还会确保“目标文件”与“源文件”具有相同的属性（比如 mode）。

## example

参考：

https://linux.cn/article-3464-1.html

https://blog.csdn.net/huangjuegeek/article/details/21713809

1. `command 2>file1`

   将stderr保存到file1中，标准输出还是显示在屏幕

2. `command 1>file1 2>file2`

   将stdout和stderr分别保存到file1和file2

3. `>&2`

   等价于`1 >&2`，将stdout重定向到stderr

4. `&>file1`

   将stoud和stderr都重定向到file1





